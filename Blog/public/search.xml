<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cocoapods采坑记 - Podfile.lock 冲突问题</title>
    <url>/posts/podfile_lock_conflict/</url>
    <content><![CDATA[<h2 id="故事的开端是这样的："><a href="#故事的开端是这样的：" class="headerlink" title="故事的开端是这样的："></a><strong>故事的开端是这样的：</strong></h2><p>我们的项目中使用了<a href="https://github.com/facebook/FBRetainCycleDetector">FBRetainCycleDetector</a>这个第三方库来检查内存泄露，在升级到某一个版本后，出现部分同事的 podfile.lock中FBRetainCycleDetector的checksum 值不一致，每次都需要运行 pod install 来更新 podfile.lock,然后git push 到仓库。其他的同事又出现 podfile.lock 冲突，需要运行 pod install 更新，然后push到 git 仓库。</p>
<span id="more"></span>

<p>喜剧上演多次后，我们采取少数服从多数的原则，让出现冲突的同事git push 的时候手动去掉 podfile.lock。</p>
<p>podfile.lock冲突<img src="/posts/podfile_lock_conflict/podfile.lock%E5%86%B2%E7%AA%81.png" class=""></p>
<h2 id="Podfile-lock-不一致的原因："><a href="#Podfile-lock-不一致的原因：" class="headerlink" title="Podfile.lock 不一致的原因："></a><strong>Podfile.lock 不一致的原因：</strong></h2><p><strong>Podfile.lock和Manifest.lock：</strong></p>
<ul>
<li>项目中集成 cocoapods 的时候，运行 pod install 后，项目根目录中会生成Podfile.lock，而Pods目录中会有Manifest.lock。</li>
<li>Xcode 编译项目的时候，会执行 Build Phases 中的[CP] Check Pods Manifest.lock 脚本，这个脚本会比对Podfile.lock和Manifest.lock，<strong>如果两个文件不相同就会报错</strong>。</li>
</ul>
<p>xcode编译脚本<img src="/posts/podfile_lock_conflict/xcode%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC.png" class=""></p>
<p>pod check失败<img src="/posts/podfile_lock_conflict/pod%20check%E5%A4%B1%E8%B4%A5.png" class=""></p>
<p><strong>Podfile.lock是什么：</strong></p>
<ul>
<li>Podfile.lock 文件主要包含三个块：PODS、DEPENDENCIES、SPEC CHECKSUMS，用来记录每个pod的版本号、依赖的其他库和每个库对应的podspec.json文件的 checksum(SHA-1算法)。通过这些信息可以确保多人协作的时候，大家使用的是相同版本的第三方库。</li>
</ul>
<p>在我们的项目中遇到的是 podfile.lock 中 checksum 部分的冲突，其实就是由于FBRetainCycleDetector.podspec.json文件的checksum不一致。</p>
<p>通过对比了有冲突的同事 mac 中生产的FBRetainCycleDetector.podspec.json文件，发现主要是repuires_arc 字段中的文件列表顺序不同。</p>
<hr>
<p>在找到问题产生的原因后，就着手解决问题：</p>
<p>一开始怀疑是MAC的 locale 不同导致文件的排序不一致，因为之前使用翻译脚本来做文件排序的时候，也出现过类似的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">system(&quot;LANG=zh_CN.utf-8 sort $tmpFileOut | uniq &gt;&gt; $fileNameOut”);</span><br></pre></td></tr></table></figure>

<p>但是在设置了 locale环境变量之后，问题还是没有解决。</p>
<p>前两天，在FBRetainCycleDetector的 issues 列表中，发现也有人遇到了<a href="https://github.com/facebook/FBRetainCycleDetector/issues/52">相同的问题</a>，更加可喜的是，这个小伙子提了一个 <a href="https://github.com/facebook/FBRetainCycleDetector/pull/53/files">PR</a> 修复了这个问题，其实只有一行代码：</p>
<p>PR 代码<img src="/posts/podfile_lock_conflict/PR%20%E4%BB%A3%E7%A0%81.png" class=""></p>
<h2 id="问题是如何解决的："><a href="#问题是如何解决的：" class="headerlink" title="问题是如何解决的："></a><strong>问题是如何解决的：</strong></h2><p>在运行 pod install 后，生成FBRetainCycleDetector.podspec.json文件中， repuires_arc字段是需要设置-fno-objc-arc的文件列表，但是不知道某种原因，出现文件路径排序在不同电脑上不同，从而导致最后FBRetainCycleDetector.podspec.json的CHECKSUMS(SHA-1) 值不一致。</p>
<p><strong>使用 sort 方法后，解决了文件排序问题。Cheers!</strong> </p>
<p>参考资料：</p>
<ul>
<li><a href="http://guides.cocoapods.org/making/specs-and-specs-repo.html">http://guides.cocoapods.org/making/specs-and-specs-repo.html</a></li>
<li><a href="http://guides.cocoapods.org/syntax/podspec.html">http://guides.cocoapods.org/syntax/podspec.html</a></li>
<li><a href="https://www.jianshu.com/p/9285be04310c">cocopods在更新过程中产生Podfile.lock 和 Manifest.lock: No such file or directory</a></li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 与 OC 混编小技巧</title>
    <url>/posts/swift-oc-mix/</url>
    <content><![CDATA[<p>Swift 与 OC交织在一起缠绵的爱情故事，在接下来的几年里将伴随着 iOS 开发人员，下面我们起来看看他们的恩怨纠葛。</p>
<span id="more"></span>

<p><strong>Swift 和ObjC混编：</strong></p>
<ul>
<li><p><strong><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216-CH2-ID0">Apple的文档</a></strong></p>
</li>
<li><p><strong>Swift中调用OC：</strong></p>
<ul>
<li><p>在 Swift 中调用 OC 的代码时，需要使用到 bridging header 文件来把 OC 的类暴露给 swift</p>
</li>
<li><p>手动添加 bridging header 的步骤，直接把 finder 中的代码文件夹拖拽到 xcode 中:</p>
<p>[图1-1]<img src="/posts/swift-oc-mix/1-1.jpg" class=""></p>
<p>如上图，需要选中“<strong>Create groups</strong>”，这样就可以在 xcode代码浏览目录中添加一个 group</p>
<p>图1-2 <img src="/posts/swift-oc-mix/1-2.jpg" class=""></p>
<p>但是，这样的操作不会让 Xcode 自动为我们创建 bridging header 文件，需要手动在 Xcode 中<strong>添加 header 文件</strong>，这里要注意命名规范，必须是“ModuleName-Bridging-Header.h”，然后设置<strong>编译选项</strong></p>
<p>图1-3<img src="/posts/swift-oc-mix/1-3.jpg" class=""></p>
<p>图1-4<img src="/posts/swift-oc-mix/1-4.jpg" class=""></p>
</li>
<li><p><strong>自动添加bridging header 的步骤</strong></p>
<ul>
<li><p>其实 xcode 可以自动添加桥接头文件，只是需要我们在刚开始的时候，<strong>拖拽一个 OC 的源文件</strong>(包含.h 和.m 文件)，而不是拖拽整个源代码的目录到 xcode 中</p>
<p>图2-1<img src="/posts/swift-oc-mix/2-1.jpg" class=""></p>
<p>图2-2<img src="/posts/swift-oc-mix/2-2.jpg" class=""></p>
</li>
<li><p>下面是拖拽 OC 源代码后的项目浏览结构，xcode自动创建一个 ModuleName-Bridging-Header.h 的头文件，并且设置好了编译选项：</p>
<p>图2-3<img src="/posts/swift-oc-mix/2-3.jpg" class=""></p>
<p>图2-4<img src="/posts/swift-oc-mix/2-4.jpg" class=""></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>OC中调用Swift：**</p>
<ul>
<li><p>OC来调用 Swift 的时候，需要依赖一个 Swift <strong>默认提供</strong>的“ModuleName-swift.h”文件，这个文件是隐藏的，<strong>不需要也不能够由开发者来提供</strong>，但是可以使用#include包含到 OC 代码中，这个 OC头文件中可以看到 swift 类、结构体、常量的定义。</p>
<p>图3-1<img src="/posts/swift-oc-mix/3-1.jpg" class=""></p>
<p>图3-2<img src="/posts/swift-oc-mix/3-2.jpg" class=""></p>
</li>
<li><p>需要注意的是，只有<strong>继承自 NSObject 的swift类才能被 OC 调用</strong>，在 swift.h 文件中是看不到纯 swift类的定义。</p>
</li>
</ul>
</li>
<li><p><strong>Swift使用OC中的宏</strong></p>
<ul>
<li>可以参考<a href="http://stackoverflow.com/questions/24325477/how-to-use-a-objective-c-define-from-swift">这个提问</a></li>
<li>有哪些问题：<ul>
<li>Swift 只能使用OC 中常量的宏定义，如<ul>
<li>#define MAX_WIDTH  100</li>
<li>#define Name_KeyPath @“Name_KeyPath”</li>
</ul>
</li>
<li>而不同使用函数调用的宏，如<ul>
<li>#define SCREEN_WIDTH  [[[UIScreen mainScreen] bounds] width]</li>
<li>#define DBQuerySuccess YES</li>
</ul>
</li>
</ul>
</li>
<li>解决方法：<ul>
<li>在 OC 文件中创建一个Constant类，使用类方法(screenWidth)来包装现有的宏定义</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>@objc 关键字的作用</strong></p>
<ul>
<li>当 swift 中要使用 OC 的一些特性的时候，如 runtime，@objc 关键字用来 提供这个功能。</li>
</ul>
</li>
<li><p>源代码</p>
<ul>
<li>具体的使用，可以参见 Github上的<a href="https://github.com/zenghao0708/SwiftOCMixing">代码</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode问题锦集</title>
    <url>/posts/xcode-tips/</url>
    <content><![CDATA[<p>Xcode 是 iOS开发人员的利器，偶尔也会变为“猪队友”，下面是本人在开发中积累的一些遇到的问题和解决方案。</p>
<span id="more"></span>

<ol>
<li><strong>代码提示不起作用</strong>：<br>This fix from apple dev forums works for me. I have had autocomplete issues with Xcode 6.1&#x2F;Yosemite.<ol>
<li>Quit Xcode.</li>
<li>Restart the computer (this is to clear any in-memory caches).</li>
<li>Delete the contents of the DerivedData folder (~&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData), precisely run,<br>a) <strong>cd ~&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;</strong><br>b) **rm -rf ***</li>
<li>(Try this if Steps 1-3 dont really work as it rebuilds the cache later on restart which takes time) Delete the contents of folder ~&#x2F;Library&#x2F;Caches&#x2F;com.apple.dt.Xcode, i.e.,<br>a) <strong>cd ~&#x2F;Library&#x2F;Caches&#x2F;com.apple.dt.Xcode</strong><br>b) **rm -rf ***</li>
<li>Now launch Xcode once more…</li>
</ol>
</li>
<li><strong>Logic Testing Unavailable</strong>：<br>Logic Testing on iOS devices is not supported. You can run logic tests on the Simulator.<br><a href="http://stackoverflow.com/questions/8454935/logic-testing-on-ios-devices-is-not-supported">http://stackoverflow.com/questions/8454935/logic-testing-on-ios-devices-is-not-supported</a><br><a href="http://stackoverflow.com/questions/8454935/logic-testing-on-ios-devices-is-not-supported">Log</a><br>ic test need a framework which has not installed with iOS device. Set a Host Application for Unit Test can resolve this issue: App will run first and Uint Test run.</li>
<li><strong>$(inherited) in xcode</strong>:<ol>
<li>inherited值的是xcode设置项的继承关系。</li>
<li>每个项目都有PROJECT的设置与TARGETS设置，TARGETS一般情况下就是继承自PROJECT</li>
</ol>
</li>
<li><strong>“Xcode 6.3: Can not verify build to install on device”</strong><ol>
<li>$(inherited) can be used to inherit build settings from the project level to the target level. When you define library or header search paths at the project level you can use $(inherited) in the target build settings to use these search paths in the search paths of the project targets.</li>
</ol>
</li>
<li><strong>Verify Xcode:</strong><ol>
<li>spctl –assess –verbose &#x2F;Applications&#x2F;Xcode.app</li>
</ol>
</li>
<li><strong>Xcode显示模拟器时，使用的是UUID，而不是系统型号</strong><ol>
<li><a href="http://stackoverflow.com/questions/26533025/xcode-using-guid-instead-of-ios-version-number-in-simulator-selection">http://stackoverflow.com/questions/26533025/xcode-using-guid-instead-of-ios-version-number-in-simulator-selection</a></li>
<li>在Xcode-&gt;Devices里，选中重复的模拟器，右键菜单“删除”，即可。</li>
</ol>
</li>
<li><strong>iPhone Simulator没有网络</strong><ol>
<li><a href="http://stackoverflow.com/questions/13542706/iphone-simulator-cannot-connect-to-internet">http://stackoverflow.com/questions/13542706/iphone-simulator-cannot-connect-to-internet</a></li>
<li>iOS Simulator (menu, top left) &gt; Reset Content and Settings… fixed it for me. Note this will delete all the apps and associated data you have on the simulator.</li>
</ol>
</li>
<li><strong>ineligible device</strong><ol>
<li>当前iOS版本比xcode版本高，就会出现这种情况，如iOS 9.1 就不能在Xcode 7上面进行调试，而只能在xcode 7.1进行调试。</li>
</ol>
</li>
<li><strong>更新xcode版本后，出现插件不兼容的问题</strong><ol>
<li><a href="http://joeshang.github.io/2015/04/10/fix-xcode-upgrade-plugin-invalid/">fix-xcode-upgrade-plugin-invalid</a></li>
<li>find ~&#x2F;Library&#x2F;Application\ Support&#x2F;Developer&#x2F;Shared&#x2F;Xcode&#x2F;Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add <code>defaults read /Applications/Xcode.app/Contents/Info.plist DVTPlugInCompatibilityUUID</code></li>
</ol>
</li>
<li><strong>检查代码中的FIXME、TODO、ERROR</strong></li>
<li><a href="http://krakendev.io/blog/generating-warnings-in-xcode">http://krakendev.io/blog/generating-warnings-in-xcode</a></li>
<li><strong>Xcode 7.3(Swift 2.2) Release配置出现Crash：</strong><ol>
<li>在Debug和Staging配置环境下的build没有问题，但是Release编译出来的build会出现crash: unrecognised selector sent to instance</li>
<li>尝试方法<ol>
<li>《<a href="http://www.jianshu.com/p/06fcd298ef4c">iOS开发调试技巧</a>》</li>
</ol>
</li>
<li>解决方法：<ol>
<li>在Swift Compiler -&gt; Code Generation选择,使用<strong>Fast [-O]，而不能使用Fast, Whole Module Optimization</strong></li>
</ol>
</li>
</ol>
</li>
<li><strong>查看所有的Simulator：</strong><ol>
<li>xcrun simctl list devices</li>
</ol>
</li>
<li><strong>Xcode 注释功能不起作用：</strong><ol>
<li>重启 Xcode,重启 MAC</li>
<li>运行：sudo usr&#x2F;libexec&#x2F;xpccachectl</li>
<li>重命名 Xcode，然后打开，恢复后，重新改名为 Xcode</li>
</ol>
</li>
<li><strong>使用 Code Snippet</strong><ol>
<li><a href="http://blog.csdn.net/wzzvictory/article/details/12163939">Xcode开发技巧之code snippets(代码片段)</a></li>
<li>&lt;#type#&gt;占位符</li>
<li>Xcode中的代码片段默认放在下面的目录中：~&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;UserData&#x2F;CodeSnippets</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode 10 beta 版本迁移指南</title>
    <url>/posts/xcode-10-migrate/</url>
    <content><![CDATA[<p>今天的主角就是开发者接触最多的 Xcode 10 beta，详细内容可以参考 <a href="https://developer.apple.com/videos/play/wwdc2018/408/">WWDC 18 Session</a> ，同时可以看下 Xcode 10 的 <a href="https://developerbetas.com/wp-content/uploads/2018/06/Xcode_10_Beta_Release_Notes.pdf">release note</a>, 官方文档永远是学习新内容的第一手资料。</p>
<p>Xcode 10 beta 在 WWDC 18后就对<a href="https://developer.apple.com/xcode/">开发者开放下载</a>了，WWDC 18的新内容不多，Apple 今年把主要精力放在 Bugfix和性能优化上面，还这几年欠下来的技术债，关于 iOS 11的诟病一直不绝入耳，不得不说，Apple 今年的决策还是比较明智的。</p>
<span id="more"></span>

<p>我们项目现在是 OC 和 Swift 混编，Xcode 版本是9.4.1，swift 4，平时用公司的 iMac Late 2013编译感觉有点吃力，用自己的 MBP 14则编译速度足够去喝杯咖啡，享受人生。</p>
<p>我尝试把自己的主力机（iPhone 7）升级到 iOS 12后，内心抑制不住冲动把14年的 iPhone 6也升级下 iOS 12试试，重新体会到了之前 iOS 的那种流畅，真的是老泪纵横。平时 iPhone 6只能沦为测试手机，跑跑单元测试啥的。</p>
<p>升级了 iOS 12后，Xcode 9已经不能进行调试了，本着生命不息，折腾不止的精神，顺带体验了一下 Xcode 10的各种新功能，总结了一下升级 Xcode 10过程中踩的坑。</p>
<ul>
<li><p>Xcode 10 beta 版本迁移指南：</p>
<ul>
<li><blockquote>
<p><strong>指定 swift版本</strong>：4.1，Xcode 10使用的是 swift 4.2版本，而 Xcode 9.4则使用 Swift 4.1,基本改动不大，为了兼容 Xcode 9，这里统一使用 Swift 4.1。</p>
</blockquote>
<ul>
<li><p>podfile设置如下:</p>
<ul>
<li>&#96;&#96;&#96;<br>config.build_settings[‘SWIFT_VERSION’] &#x3D; ‘4.1’<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    ​</span><br><span class="line"></span><br><span class="line">- xcode 项目设置：</span><br><span class="line"></span><br><span class="line">  - **SWIFT_VERSION**为 swift 4</span><br><span class="line"></span><br><span class="line">- xcode command tool设置: 使用 Xcode 10</span><br><span class="line"></span><br><span class="line">  - sudo xcode-select --switch /Applications/Xcode-beta.app</span><br><span class="line"></span><br><span class="line">  - xcodebuild -version可以查看</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      - Xcode 10.0</span><br><span class="line">      - Build version 10L176w</span><br></pre></td></tr></table></figure>

  ​</li>
</ul>
</li>
</ul>
</li>
<li><blockquote>
<p>更新部分 pod 库：</p>
</blockquote>
<ul>
<li>RACObjcBridge&#x2F;RACObjc升级到3.1.0，之前是3.0.0版本，swift 版本导致需要升级。</li>
<li>删除 Tencent SDK pod spec 中的s.resource_bundle字段，参见 xcode 10 beta release note。多个相同的输入文件导致冲突，这个也是 xcode 10新增的功能，为了加快编译速度，对编译依赖检测得很严格。</li>
<li>使用 Carthage 的话，则需要指定手动指定 Swift 版本：<ul>
<li>carthage update –platform iOS –toolchain com.apple.dt.toolchain.Swift_4_1 –no-use-binaries REPO_NAME</li>
</ul>
</li>
</ul>
</li>
<li><blockquote>
<p>更新 swift lint: disable identifier_name</p>
</blockquote>
<ul>
<li>参见<a href="https://github.com/realm/SwiftLint/issues/2231">False positive for rule identifier_name in Xcode 10 beta</a></li>
</ul>
</li>
<li><blockquote>
<p>其他错误：</p>
</blockquote>
<ul>
<li><a href="https://github.com/mapbox/mapbox-gl-native/issues/12084">Command CompileC failed with a nonzero exit code</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>整个升级过程中，需要注意的几点：</p>
<ul>
<li>及时清理 DerivedData目录，由于整个编译过程中会产生众多的中间文件，非常容易导致编译依赖检测出错。</li>
<li>更新 carthage framework和使用 pod install 重新编译第三方库。</li>
<li>New Build System: Xcode 9.4引入了 preview 版本，Xcode 10则是默认开启，开启后，编译速度确认有所提升，但是也会导致一些比较奇怪的编译问题，上面只是记录了笔者遇到的几个问题。</li>
<li>完成升级后，Xcode 9.4和 Xcode 10 beta 可以共存，笔者使用 Xcode 10 beta，其他开发同事继续使用 Xcode 9。</li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS多线程开发笔记</title>
    <url>/posts/ios-thread-tips/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="GCD、NSOperation和多线程编程推荐阅读"><a href="#GCD、NSOperation和多线程编程推荐阅读" class="headerlink" title="GCD、NSOperation和多线程编程推荐阅读"></a>GCD、NSOperation和多线程编程推荐阅读</h2><p><strong>五星：</strong></p>
<ol>
<li><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/">iOS 并发编程之 Operation Queues</a></li>
<li><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md#gcd-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86">GCD 深入理解：第一部分</a></li>
<li><a href="http://blog.csdn.net/zyq522376829/article/details/52373154">iOS并发编程对比总结,NSThread,NSOperation,GCD - iOS</a></li>
</ol>
<p> </p>
<p><strong>四星：</strong></p>
<ol>
<li><a href="http://nshipster.cn/nsoperation/">NSOperation in NShipster</a> </li>
<li><a href="http://www.cppblog.com/kesalin/archive/2011/08/26/154411.aspx">深入浅出 Cocoa 多线程编程之 block 与 dispatch quene</a></li>
<li><a href="http://tutuge.me/2015/04/03/something-about-gcd/">GCD使用经验与技巧浅谈</a></li>
</ol>
<span id="more"></span>

<h2 id="多线程编程概念"><a href="#多线程编程概念" class="headerlink" title="多线程编程概念"></a>多线程编程概念</h2><h3 id="基本概念、术语："><a href="#基本概念、术语：" class="headerlink" title="基本概念、术语："></a>基本概念、术语：</h3><ol>
<li>进程（Precess）：进程是操作系统管理和分配资源的最小单位，每个进程都有自己的内存空间、系统资源，至少有一个主线程和多个辅助线程。在iOS中，每个App运行的时候，都有对应的进程。</li>
<li>线程（Thread）：线程则是操作系统具体的执行单元，代码的执行是在线程来完成的。在iOS中，线程的底层实现是基于POSIX thread API的，也就是我们常说的pthread。</li>
<li>任务（Task）：任务是我们抽象出来的需要执行的工作，一般指代一段代码。</li>
<li>同步 vs 异步<ol>
<li>同步是指函数的调用会阻塞当前的线程，必须等待函数返回才能继续执行接下来的代码。</li>
<li>异步函数的调用则不会阻塞当前线程，函数调用之后立刻返回，一般通过回调函数来处理函数的执行结果。</li>
<li>异步函数能够有效的完成一些耗时的任务，而不必影响代码的执行流，能够提高代码的处理效率。</li>
</ol>
</li>
<li>串行 vs 并发<ol>
<li>串行指的是在同一个时间只能有一个任务在执行。</li>
<li>并发指的是在同一个时间可以有多个任务一起执行。</li>
<li>并发一般用于多核编程，通过高效的利用多核的优势，把不同的任务分配到各个执行单元来提高效率。</li>
</ol>
</li>
<li>Dispatch Queue vs Operation Queue<ol>
<li>GCD和NSOperation&#x2F;NSOperationQueue是iOS上面来处理多线程开发的工具，对应的概念分别是Dispatch Queue和Operation Queue。</li>
</ol>
</li>
</ol>
<h3 id="iOS并发编程模型"><a href="#iOS并发编程模型" class="headerlink" title="iOS并发编程模型"></a>iOS并发编程模型</h3><ol>
<li>在其他的操作系统中，我们往往需要手动创建线程、管理线程的生命周期，在不需要的时候负责销毁线程和线程使用的资源，更加痛苦的是需要使用线程锁、信号量、代码临界区等手段完成线程的同步工作，这些操作往往容易出错而且繁杂。</li>
<li>iOS通过抽象出队列的概念，让开发者更加关注于任务的安排和调度，而从线程的管理工作中解脱出来。在很多时候，iOS把一些繁杂且容易出错的工作（ARC代替MRC）抽离到底层中，能够让开发者把注意力更多地放到真正的任务上，这也是iOS能够吸引广大开发者的原因之一吧。</li>
</ol>
<h2 id="NSThread-vs-GCD-vs-NSOperation，它们到底是什么？"><a href="#NSThread-vs-GCD-vs-NSOperation，它们到底是什么？" class="headerlink" title="NSThread vs GCD vs NSOperation，它们到底是什么？"></a>NSThread vs GCD vs NSOperation，它们到底是什么？</h2><h3 id="三种解决方案"><a href="#三种解决方案" class="headerlink" title="三种解决方案"></a>三种解决方案</h3><ol>
<li>NSThread：一个封装pthread API的线程对象，需要进行线程创建、销毁和处理线程同步，是最接近系统底层的解决方案。</li>
<li>GCD：苹果基于C语言开发的，一个用于多核编程的解决方案，是一个轻量级的、以FIFO的顺序来执行并发任务的库。</li>
<li>NSOperation：建立在GCD的基础上，面向对象的解决方案，比GCD更加灵活，也更加强大。</li>
</ol>
<h4 id="它们具体是什么？"><a href="#它们具体是什么？" class="headerlink" title="它们具体是什么？"></a>它们具体是什么？</h4><ol>
<li>NSThread: Cocoa对于pthread API的封装，提供了一套面向对象的接口，需要开发者自行管理线程的生命周期、处理线程同步。大多是的时候，我们是不需要直接使用这些底层的对象，而是使用GCD或者NSOperation等更加高级的接口。</li>
<li>关于Operation对象<ol>
<li>NSOperation对象本身是一个抽象类，不能直接使用。要么使用系统预定义的两个子类NSInvocationOperation和NSBlockOperation或者定义它的子类。</li>
<li>NSInvocationOperation:可以使用<strong>object</strong>和<strong>selector</strong>来创建一个NSInvocationOperation，非常的方便和灵活。当代码中已经有相关的处理逻辑方法时，建议直接使用NSInvocationOperation来进行替代。</li>
<li>NSBlockOperation：可以使用NSBlockOperation来并发的执行一个或者多个block，只有当所有的block都执行完毕，NSBlockOperation才算执行完成，有点像dispatch_group的概念。</li>
<li>所有的Operation都有下面的特性：<ol>
<li>支持在 operation 之间建立依赖关系，只有当一个 operation 所依赖的所有 operation 都执行完成时，这个 operation 才能开始执行；</li>
<li>支持一个可选的 completion block ，这个 block 将会在 operation 的主任务执行完成时被调用，在任务被取消的时候也会执行；</li>
<li>支持通过 KVO 来观察 operation 执行状态的变化，Operation正是通过KVO通知来实现依赖运行，所以我们需要在自定义的子类中的处理好KVO的属性；</li>
<li>支持设置执行的优先级，从而影响 operation 之间的相对执行顺序；</li>
<li>支持取消操作，可以允许我们停止正在执行的 operation 。</li>
</ol>
</li>
</ol>
</li>
<li>GCD队列：<ol>
<li>以FIFO顺序执行任务的队列调度系统，先入队列的任务一定先执行。</li>
<li>两种类型的队列：<ol>
<li>串行队列（Serial Queue）:同一时间内只能有一个任务正在被执行。</li>
<li>并发队列（Concurrent Queue）:同一时间内可以有多个任务同时被执行。</li>
<li>iOS默认提供5个队列：<ol>
<li>主队列（Main Queue）：应用程序主线程应用的队列，用于更新UI，属于串行队列。</li>
<li>四个全局队列：<ol>
<li>按照队列优先级排序，分别是：High、Default、Low、Background。</li>
<li>这四个全局队列是由系统提供的，在所有的App中共享，当然也包含了Apple的应用。</li>
</ol>
</li>
<li>并发队列中任务的执行顺序：<ol>
<li>由于队列的并发数是有系统根据当前的资源动态管理的，我们不知道也不能够设置队列中任务执行的时机和所需时长。</li>
<li>只有当位于队列前面的任务执行完毕、出队列后，才会执行后面的任务，但是当前并发执行的任务数量我们不得而知。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>自定义队列：<ol>
<li>我们可以自定义串行或者并发队列来完成任务的执行和调度。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="各自的优势和劣势"><a href="#各自的优势和劣势" class="headerlink" title="各自的优势和劣势"></a>各自的优势和劣势</h3><ol>
<li>优势：<ol>
<li>NSThread：<ol>
<li>能够执行实时任务。其他两者都是由系统管理的队列，不能保证实时性。</li>
</ol>
</li>
<li>GCD：<ol>
<li>可以非常简洁的完成简单异步任务的调用，如在主线程更新UI，延迟执行。</li>
<li>只需要把任务分发到队列之后，不需要管理任务的调度情况。</li>
</ol>
</li>
<li>NSOperation：<ol>
<li>给任务添加依赖</li>
<li>取消或者暂停一个正在执行的任务</li>
<li>有一个可选的completionBlock</li>
<li>可以通过KVO来查看任务的执行情况</li>
<li>可以给任务设置优先级，从而影响任务的执行顺序</li>
</ol>
</li>
</ol>
</li>
<li>短板：<ol>
<li>NSThread：需要进行线程的创建、销毁，以及处理线程同步的问题，过于繁杂，而且容易出错。</li>
<li>GCD:<ol>
<li>对于任务的管理不够：如不能取消任务、设置依赖和优先级等。</li>
</ol>
</li>
<li>NSOperation:<ol>
<li>相比于GCD，会增加系统的额外开销。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="多线程代码中，需要注意哪些问题？"><a href="#多线程代码中，需要注意哪些问题？" class="headerlink" title="多线程代码中，需要注意哪些问题？"></a>多线程代码中，需要注意哪些问题？</h2><ol>
<li>有了GCD来调度block，我们为什么还需要NSBlockOperation?<ol>
<li>现有代码已经在使用OperationQueue，而我们不想使用Dispatch Queue的时候，NSBlockOperation提供了一个面向对象的封装。</li>
<li>当我们需要dispatch queue不能提供的功能时，如KVO观察Operation状态变化、设置operation之间依赖等。</li>
</ol>
</li>
<li>NSInvocationOperation的灵活性是什么意思？<ol>
<li>我们可以通过上下文来改变selector和object对象。</li>
</ol>
</li>
<li>如何定义一个非并发的operation？<ol>
<li>对于非并发的operation，我们只需要实现main方法和能够正常响应取消事件。</li>
<li>其他复杂的工作如KVO通知、依赖设置等工作NSOperation类的start方法已经帮我们提供了默认实现。</li>
<li>简单实现：<ol>
<li>提供一个自定义的初始化方法</li>
<li>重写main方法</li>
</ol>
</li>
</ol>
</li>
<li>如何实现一个并发的operation？<ol>
<li>一般我们不需要实现并发的operation，当operation和operation queue一起使用的时候，Operation Queue会为非并发的operation创建单独的线程。</li>
<li>默认情况下，operation是同步执行的，也就是我们直接使用start方法的时候，它是在调用者的线程中执行的。</li>
<li>Operation的isConcurrent属性表明一个operation是否支持并发。</li>
<li>配置并发的Operation：只有当我们需要手动执行operation，并且希望支持并发执行，需要重写下面的方法。<ol>
<li>start：必须，配置任务执行的线程和其他资源，但是一定<strong>不能调用父类的实现</strong>。</li>
<li>main：可选，一般用来执行具体的任务，而start方法更多是用来配置初始环境，当然也可以用来执行具体的任务。</li>
<li>isExecuting和isFinished：必须，并发的Operation需要自己来配置环境，同时还需要向外界来传递状态的变化，而isExecuting和isFinished这两个状态的变化需要使用KVO来通知外部。</li>
<li>isConcurrent：必须，用来标识一个Operation是否支持并发。</li>
</ol>
</li>
</ol>
</li>
<li>如何完成自定义operation的cancel操作？<ol>
<li>在下面这几个关键点的检查isCancelled属性<ol>
<li>在真正开始执行operaiton之前</li>
<li>至少在一次循环之中需要检查一次，如果单次循环耗时较长，则需要更加频繁的检查</li>
<li>在任何相对比较容易终止Operation的地方</li>
</ol>
</li>
<li>需要注意的是虽然Operation支持取消操作，但是并不是立刻就可以被终止的，而是在下一个isCancelled的检查点。</li>
<li>在我们自定义Operation子类的时候，即使operation是被cancel了，我们仍然需要设置isFinished方法为true，因为在设置operation依赖的时候，它们的operation就是通过KVO来观察isFinished方法来判断时候可以执行的，如果在cancel的时候，没有设置isFinished方法，那么其他的operation将永远不会执行。</li>
</ol>
</li>
<li>如何定制Operation对象的执行行为：<ol>
<li>在Operation添加到Operation Queue之前，我们可以配置Operation的一些行为。</li>
<li>配置依赖关系<ol>
<li>依赖关系是在Operation之间的，与是否在同一个Operation Queue没有关系，也就是说，我们在位于不同的Operation Queue中的Operation之间设置依赖。</li>
<li>注意不要产生依赖循环。</li>
<li>在把operation添加到Operation Queue之前就需要配置好依赖，在添加后设置的依赖可能无效。</li>
</ol>
</li>
<li>修改operation在队列中的优先级<ol>
<li>Operation在队列中的执行顺序取决于isReady状态和队列优先级。</li>
<li>isReady受它所依赖的operation状态的影响，只有当依赖的所有operation都变为isFinished的时候，isReady状态才为true。</li>
<li>queuePriority只能作用与相同队列中的operation，并且队列优先级只有当isReady为true的时候，才会决定operation的执行顺序。</li>
<li>isReady为FALSE的时候，isReady为true的低队列优先级的operation也会先执行。</li>
</ol>
</li>
</ol>
</li>
<li>一个串行的 operation queue 与一个串行的 dispatch queue是一样的么？<ol>
<li>两者都是在同一时间内只能有一个任务被执行，但是在任务的执行顺序上是不同的：<ol>
<li>dispatch queue 的执行顺序一直是 FIFO 的</li>
<li>operation queue中的operation执行的顺序取决于isReady和queuePriority状态。</li>
</ol>
</li>
</ol>
</li>
<li>如何用GCD实现一个线程安全的单例？<ol>
<li>ObjC</li>
<li>Swift</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用手册</title>
    <url>/posts/git_manual/</url>
    <content><![CDATA[<p>Git 是每个开发童鞋必须掌握的工具，本文记录博主日常开发使用 git时，遇到的问题和常用的解决方法：</p>
<span id="more"></span>

<ol>
<li>No submodule mapping found in .gitmodules for path ‘Frameworks&#x2F;XXX’<ol>
<li>参考：<a href="http://stackoverflow.com/questions/1260748/how-do-i-remove-a-git-submodule">http://stackoverflow.com/questions/1260748/how-do-i-remove-a-git-submodule</a></li>
<li>$<strong>git submodule</strong></li>
<li>$<strong>git rm ‘Frameworks&#x2F;XXX’</strong></li>
</ol>
</li>
<li>检查非法的branch名字<ol>
<li>A branch name can not:</li>
</ol>
</li>
</ol>
<ul>
<li>Have a path component that begins with “.”</li>
<li>Have a double dot “..”</li>
<li>Have an ASCII control character, “~”, “^”, “:” or SP, anywhere</li>
<li>End with a “&#x2F;“ - End with “.lock”</li>
<li>Contain a “&quot; (backslash</li>
</ul>
<ol start="3">
<li>拉取其他分支代码到当前分支：Git pull rebase<ol>
<li>当我们需要从别的分支上面拉取代码，并且希望被拉取的commit能够很好地rebase到当前分支,我们就需要用到pull rebase</li>
<li>示例：从develop拉取代码到当前分支：<ul>
<li>确保本地分支代码和develop都已经push到origin</li>
<li>git pull –rebase origin develop<ul>
<li>把develop分支代码拉取到当前分支，此时会发现当前分支和develop分支代码并没有rebase,还是在两条不同的线上</li>
<li>拉取完成后会发现如下的一些提示：<ul>
<li>On branch feature&#x2F;music</li>
<li>Your branch and ‘origin&#x2F;feature&#x2F;xxx’ have diverged,</li>
<li>and have 9 and 6 different commits each, respectively.</li>
<li>(use “git pull” to merge the remote branch into yours)</li>
<li>nothing to commit, working directory clean</li>
</ul>
</li>
</ul>
</li>
<li>git push -f<ul>
<li>把本地分支和develop分支强行push到origin</li>
<li>git push 会导致错误，因为使用pull rebase操作会生成两个不同的分支（Your branch and ‘origin&#x2F;feature&#x2F;music’ have diverged）</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>Git分支管理策略<br>  1.推荐阅读 《<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git分支管理策略 - 阮一峰的网络日志</a>》</li>
<li>git workflow:<br> 1. 只需要保留master和develop分支。<br> 2. 日常开发时，从develop上面开一个feature分支，完成开发后，按需merge到develop分支中，merge成功后，可以删除feature分支。<br> 3. 发布前，使用release分支<br> 4. 产品上线后，使用从master分支fork出hotfix分支，完成bug修复后，merge到master和develop分支。</li>
<li>Github pull request<ol>
<li>《Mort | Pull Request的正确打开方式（如何在GitHub上贡献开源项目）》 – 原文404，可以参考转载</li>
</ol>
</li>
<li>Github Repo Migration:<ol>
<li>Github fork repo</li>
<li>Github import repo</li>
</ol>
</li>
<li>Git 修改commit message:<ol>
<li>git commit –amend -m “New commit message”</li>
</ol>
</li>
<li>查找commit message:<ol>
<li>git log –oneline | grep PATTERN</li>
</ol>
</li>
<li>多个github账号的管理：</li>
<li><a href="https://gist.github.com/jexchan/2351996">https://gist.github.com/jexchan/2351996</a></li>
<li>本人常年使用公司和个人的Github帐号，在正确配置github帐号后，可以用命令行进行帐号切换。</li>
<li>清除git缓存：<ol>
<li>有的时候会出现.gitignore文件不起作用的情况，需要清理git缓存：</li>
<li>$ git rm –cached -r FOLDER_NAME</li>
<li>$ git add .</li>
<li>$ git commit -m “COMMIT_MSG”</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 网络安全之SSL Pinning</title>
    <url>/posts/ios-ssl-pinning/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言：</strong></h2><p>Apple要求所有的 App 在2017年1月必须强制使用 ATS(Application Transport Security)，即 App 必须使用 HTTPS，而不能使用 HTTP 网络协议。这是Apple 在 app 安全领域做出的一个重大的举动，HTTP 由于使用明文进行传输，存在很大的安全隐患，网络请求容易被拦截和篡改。HTTPS 在安全性上相较于 HTTP 有很大的提升，依然存在一些问题：如 <a href="http://www.secbox.cn/hacker/7846.html">MITT</a>(Man-In-The-Middle)中间人攻击和2014年 SSL 的<a href="http://www.ithome.com/html/soft/80224.htm">心脏出血漏洞</a>。网络安全的问题看似离我们很远，其实就发生在我们身边，对我们的日常生活也会有很大的影响，特别是在移动互联网的浪潮下，人手一台手机的情况下，大家普遍使用支付宝和微信支付来进行支付，能够联网的智能家居产品越来越多的走入到普通家庭中，网络安全是一个需要引起重视的问题。而在网络传输过程中起到安全保障作用的，就是我们今天要讲的 SSL&#x2F;TLS，当然主要是集中在 iOS 客户端。</p>
<span id="more"></span>

<h2 id="0x00-什么是-SSL-x2F-TLS"><a href="#0x00-什么是-SSL-x2F-TLS" class="headerlink" title="0x00 - 什么是 SSL&#x2F;TLS"></a><strong>0x00 - 什么是 SSL&#x2F;TLS</strong></h2><p>SSL(Secure Sockets Layer 安全套接层)及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。SSL为Netscape所研发，用以保障在Internet上数据传输的安全，利用数据加密(Encryption)的技术，可确保数据在网络上的传输过程中不会被截取及窃听。SSL协议位于TCP&#x2F;IP协议与各种应用层协议之间，为数据通讯提供安全支持。 <strong>— 摘自《互动百科》</strong></p>
<p>从上面的定义可以看出 SSL 是一个加密层，主要用于信息加密、验证。</p>
<p>SSL 主要提供下面三个服务：</p>
<ol>
<li><strong>认证用户和服务器</strong>，确保数据发送到正确的客户机和服务器；</li>
<li><strong>加密数据</strong>以防止数据中途被窃听；</li>
<li>维护<strong>数据的完整性</strong>，确保数据在传输过程中不被改变。</li>
</ol>
<h2 id="0x01-什么是-HTTPS"><a href="#0x01-什么是-HTTPS" class="headerlink" title="0x01 - 什么是 HTTPS"></a><strong>0x01 - 什么是 HTTPS</strong></h2><p>HTTPS（Hypertext Transfer Protocol Secure 安全超文本传输协议） 是由 Netscape 开发并内置于其浏览器中，用于对数据进行压缩和解压操作，并返回网络上传送回的结果，HTTPS 实际上运用了 Netscape 的完全套接字层（SSL）作为 HTTP 应用层的子层。</p>
<h2 id="0x02-SSL-Pinning-是什么"><a href="#0x02-SSL-Pinning-是什么" class="headerlink" title="0x02 - SSL Pinning 是什么"></a><strong>0x02 - SSL Pinning 是什么</strong></h2><p>当前主流的各大网站 Google、Facebook 等都使用 HTTPS 来保障数据的安全性和私密性，但是在 HTTPS 协议也存在一定的问题，其中广为人知是 MIIT（中间人工具），攻击者在客户端和服务器中进行伪装和欺骗，从而获取敏感信息。</p>
<p>SSL Pinning 是一个业界预防 MIIT 攻击的解决方案，其主要思想是在客户端绑定（Pin）服务器SSL 证书的核心信息，这个解决方案代价小，易于实施，因此被普遍使用。</p>
<h2 id="0x03-在-iOS-中如何使用-SSL-Pinning"><a href="#0x03-在-iOS-中如何使用-SSL-Pinning" class="headerlink" title="0x03 - 在 iOS 中如何使用 SSL Pinning"></a><strong>0x03 - 在 iOS 中如何使用 SSL Pinning</strong></h2><p>iOS 中的 SSL Pinning 主要有三种形式：</p>
<ol>
<li>直接使用 NSURLSession</li>
<li>配合AFNetworking 使用</li>
<li>配合 Alamofire 使用</li>
</ol>
<p>NSURLSession 是 iOS 系统提供的类，AFNetworking 和 Alamofire 识别是 ObjC和 Swift 编写的第三方库，具体实施步骤，可以参考<a href="https://infinum.co/the-capsized-eight/how-to-make-your-ios-apps-more-secure-with-ssl-pinning">这篇 blog</a>。</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a><strong>参考文章：</strong></h2><ul>
<li><a href="http://www.baike.com/wiki/ssl&prd=button_doc_entry">SSL - 互动百科</a></li>
<li><a href="http://baike.baidu.com/item/ssl">SSL - 百度百科</a></li>
<li><a href="https://infinum.co/the-capsized-eight/how-to-make-your-ios-apps-more-secure-with-ssl-pinning">How to make your iOS apps more secure with SSL pinning</a></li>
<li><a href="http://www.secbox.cn/hacker/7846.html">iOS环境下的中间人攻击风险浅析</a></li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>《人生战术本》- 里弗斯教练帮助他人“成为更好的人”</title>
    <url>/posts/the-palybook/</url>
    <content><![CDATA[<p>本文内容节选自 Netflix 20 年推出的纪录片《人生战术本》（The Playbook）第一季第一集，主人公是拥有 22 年 NBA 执教经验的主教练道格·里弗斯。</p>
<span id="more"></span>

<img src="/posts/the-palybook/the-playbook.png" class="">

<p>“我是里弗斯，我是人，我也会犯错”，开场白非常的平易近人，让人倍感亲切~</p>
<p><strong>做你自己喜欢的事情，你才不会觉得累。</strong></p>
<p>几十年来，里弗斯起床到篮球场去训练，但是他不喜欢用“训练”这个词，当被人问到去做什么的时候，他总是喜欢说去“打篮球”。里弗斯小时候被问到成长以后想变成一个什么样的人，第一次他在黑板上面写到“成为一名 NBA球员”但是被老师给擦掉了，然后对他说道“降低预期，现实一点”，于是当里弗斯第二次在黑板上面写到“我想成为一名 NBA 球员”，老师让他直接回家请家长了“那你收拾好自己的东西回家想想吧”。</p>
<p>回到家里，里弗斯的爸爸这样对他说“你在学校没有好好听老师讲课，你总是把事情搞砸、喜欢胡闹，你以后当不了职业球员”，最终里弗斯不仅成为了 NBA球员，到目前为止也在 NBA执教了 20 多年，这一切出自于他对篮球的喜爱和坚持吧</p>
<p><strong>凯尔特人第十八冠的故事 -不会熄灭的灯和“乌班图”的生活方式</strong></p>
<p>他和队员都在一起践行“乌班图”的生活方式，在团队中相信他人、成就他人，最终形成一个“共同体”。</p>
<p>在比赛前夕里弗斯的父亲去世了，他离开团队飞回老家参加父亲的葬礼，当里弗斯和家人在电视机前面观看比赛的时候，中场休息时间收到了加内特打过来的电话，加内特说道“当你难过的时候，我们也感到很难过”，里弗斯谈到此情此景的时候都会感到很激动。那场比赛在的最后 7 秒钟，皮尔斯把球传给了雷·阿伦，由雷·阿伦投入了制胜三分最终帮助球队完成逆转，我们通过电视转播能够看到凯尔特人逆转比赛、看到赢得胜利之后队员们欢快的庆祝，但是背后的故事也挺让人感动。</p>
<p>有一场比赛胜利之后，记者问加内特“今晚你非常注重防守，你觉得自己在防守方面有哪些地方做的比较好？”，“不是我，而是我们。我在我应该在的位置，而我的队友们也在他们应该在的位置（这样才能不失位）。我们需要靠这种积极的补位来赢得比赛”，加内特给出了这样的回答。</p>
<p>有一天里弗斯在球馆上方的 17 块总冠军旗帜旁边打了一个灯光，寓意“不会熄灭的灯”，当天训练介绍之后他询问球员们今天球馆有什么不同的地方，只有托尼·阿伦发现在球馆上方多出了一块光。“是的，灯不会熄灭，我们的焦点就在那里，我们比赛就是为了这个”，“每天、每次练习，他们都看到那盏灯照着墙”，激发队员们“我们是波士顿凯尔特人队，我们就是要赢”。</p>
<p>里弗斯谈到自己的偶像是拳王阿里，“直觉上大家会觉得冠军是不被击打的，但是事实其实是相反的，冠军会被一次次的击打，就看你能挨多少次打，同时还要向前进，直到取得胜利”。</p>
<p>一个好的教练，需要让自己的队员相信自己能够赢得下一场比赛。里弗斯小的时候的目标就是击败自己的哥哥，哥哥比他健壮、力量更强，从最开始32：0到 32：4，然后到 32：8，通过自己持续练习、一步步成长起来最终击败了哥哥。</p>
<p>一开始里弗斯认为自己作为主教练的职责是带领团队赢得一场场的胜利，后面能够通过指导队员、看着他们逐渐成熟起来、“打出来”也是一种喜悦或者说幸福。不过，他也有收到过一些忠告“不要和团队成员走得太近了，因为总有人会让你失望”。但是里弗斯认为教练的职责就是指导他们，让他们成为更好的球员、更好的人、更好的队友、变得坚强、有热情，学会面对赢输。</p>
<p>19 年CBA的 官方纪录片《敢梦敢当》里面，看到了杜峰作为球队主教练的成长，也看到了他不为人知的一面：一个有血有肉的人、体贴他人、关注成长、激励队员。在竞技体育里面，一个团队要想在顶级舞台上面想要夺得冠军，背后一定是付出了巨大的努力，除了日复一日的练习，研究对手的强弱点，还需要一名优秀的教练，给大家带来前进的方向，激励团队里面的每一个人成为更好的自己。 </p>
<hr>
<p>《人生战术本》分享了传奇教练在运动和生活中取得成功所遵循的规则。通过感人的深度访谈，每位教练都透露了他们个人生活和职业生涯中的关键时刻，这些时刻最终帮助他们形成了自己的教练哲学。</p>
<p>B站链接：<a href="https://www.bilibili.com/video/BV1WA411J76h">https://www.bilibili.com/video/BV1WA411J76h</a></p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo+github page搭建个人博客</title>
    <url>/posts/hexo_build/</url>
    <content><![CDATA[<p>我的这个博客就是使用hexo+github搭建起来的，这篇文章记录了相关步骤和一些需要注意的地方。</p>
<p>2018年2月18日更新：域名绑定和https 访问问题。</p>
<span id="more"></span>

<h2 id="首先简单介绍下github-page和hexo："><a href="#首先简单介绍下github-page和hexo：" class="headerlink" title="首先简单介绍下github page和hexo："></a>首先简单介绍下github page和hexo：</h2><ul>
<li>Github Page: 使用github repo的静态网页工具，可以无缝地与github一起使用，每个github帐号都有400M的免费空间来存放博客文件，具体的使用说明可以参看<a href="https://pages.github.com/">github page网站</a></li>
<li>hexo:一个node.js的框架，使用npm进行安装和配置，能够快速的搭建静态博客。主要特点是搭建快速、支持markdown编辑、一键部署、本地预览。</li>
<li>使用github page+hexo主要是考虑到能够快速搭建、维护方便、技术栈匹配。</li>
</ul>
<p>下面来说具体的搭建步骤，这里使用<strong>MAC的开发环境</strong>：</p>
<ul>
<li><p>配置github repo：</p>
<ul>
<li>新建一个username.github.io的仓库，注意一定要使用自己的<strong>github用户名</strong></li>
<li>设置ssh key：参见<a href="https://help.github.com/articles/generating-an-ssh-key/">github ssh教程</a></li>
<li>这里需要说明的是：github page默认使用的是<strong>master分支</strong>，在master分支中的<strong>index.html</strong>文件会被解析并且作为网页的入口。</li>
</ul>
</li>
<li><p>安装Hexo命令行工具hexo-cli</p>
<ul>
<li>参考<a href="https://hexo.io/docs/index.html">官方教程</a></li>
<li>安装git、Node.js等工具</li>
<li>安装hexo-cli命令行工具：npm install -g hexo-cli<ul>
<li>hexo-cli是hexo的命令行工具，用于执行hexo init</li>
</ul>
</li>
<li>Setup Hexo:<ul>
<li>命令行为：hexo init <folder></li>
<li>使用hexo的模板生成项目，下面几个文件比较重要：<ul>
<li>package.json: Node js用于指定依赖包的配置文件，在不清楚的情况下，不要随意修改。</li>
<li>_config.yml: hexo的配置文件，可以设置网站title、主题、字体、制定域名等。</li>
<li>source: Blog的源文件目录，使用hexo new生成的md文件存放在这个目录中。</li>
<li>scaffolds：模板文件，hexo new使用它来生成新的模板md。</li>
<li>themes：主题目录，设置网站版式。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>写Blog：</p>
<ul>
<li>hexo new post_title：生成新的模板文件。</li>
<li>注意：这里使用hexo命令和上面的hexo init不是同一个命令，这个hexo是在setup过程中下载的npm包，<strong>需要在Blog这个目录中使用才有效。</strong></li>
<li>生成的文件在source&#x2F;_post目录中，使用markdown编辑器来写博客。</li>
</ul>
</li>
<li><p>本机调试：</p>
<ul>
<li>在写blog的过程中，可以直接在本机进行预览：hexo serve</li>
<li>默认使用4000端口，还可以<a href="https://hexo.io/docs/server.html#Custom-IP">设置其他的端口</a></li>
</ul>
</li>
<li><p>生成Blog文件：</p>
<ul>
<li>生成编译后的blog：hexo generate</li>
<li>生成后的文件存放在public目录中</li>
<li>也可以使用下面的命令直接完成发布: hexo generate —deploy</li>
</ul>
</li>
<li><p>发布blog：</p>
<ul>
<li>使用hexo deploy完成发布</li>
<li>第一次发布之前，需要修改_config.yml文件，参见：<a href="https://hexo.io/docs/deployment.html#Git">hexo deploy</a></li>
</ul>
</li>
<li><p>最后要说下Troubleshooting和需要注意的地方:</p>
<ul>
<li>hexo new不起作用<ul>
<li>我们需要另外开一个branch来进行blog的写作（如source分支），然后使用hexo deploy到master分支上面。在不同的分支进行切换的时候，由于.gitignore文件不一样，导致我们可能在master分支上面删除了一些source分支上面重要的文件，如node_modules目录，则需要我们在切换到source分支的时候，重新下载npm包：npm i</li>
</ul>
</li>
<li>hexo deploy失败<ul>
<li>需要安装hexo-deployer-git包，参考 <a href="https://hexo.io/docs/deployment.html#Git">hexo deploy</a></li>
</ul>
</li>
<li>master分支的使用方法<ul>
<li>master分支上面<strong>不要放文件</strong>，这个分支在使用hexo deploy之后自动更新，所以会覆盖我们自己的文件。</li>
</ul>
</li>
<li>使用source分支来进行写作<ul>
<li>上面提高了不能使用master分支，那么就需要我们使用别的分支来进行hexo的搭建和写作，我个人使用source分支，当然你也可以取一个自己喜欢的名字。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="—-2018年2月18日更新："><a href="#—-2018年2月18日更新：" class="headerlink" title="— 2018年2月18日更新："></a>— 2018年2月18日更新：</h2></li>
<li><h3 id="绑定域名："><a href="#绑定域名：" class="headerlink" title="绑定域名："></a><strong>绑定域名</strong>：</h3><p>绑定域名主要分为3个步骤：申请域名、Github Page 设置域名、域名解析</p>
<ul>
<li><p>申请域名</p>
<ul>
<li>国内：<a href="https://wanwang.aliyun.com/domain/com/">万网</a>、<a href="http://www.xinnet.com/domain/domain.html">新网</a></li>
</ul>
<p>国内域名申请有一些繁杂的手续和步骤，特别是域名备案。</p>
<ul>
<li>国外：<a href="https://www.godaddy.com/">GoDaddy</a>、<a href="https://www.namecheap.com/">namecheap</a>、<a href="https://www.name.com/">name</a>、<a href="http://www.enom.com/">enom</a></li>
<li>国外的域名则相对操作简单很多，一般只需要提供联系方式即可，主要注意的是：Godaddy没有提供免费的域名信息保护功能，需要付费购买，否者别人可以通过 whois 查到域名持有者的信息。</li>
</ul>
</li>
<li><p>设置 Github Page 的域名</p>
<ul>
<li>Github Page提供域名比对的功能，只需要在网站的根目录中添加 CNAME（全部大写）文件，填写自己申请的域名（一般是<a href="http://baike.baidu.com/link?url=nBRFxvXXBbhf6esboaTgsAPqBASt6IT7cXro_okFQ9Xe8MOEaCnFOuJ1jxg0BRirAdJPU4XRrKZkYZSKzry4EmR21yJdMGuqG2TzJigDYipm0ZAAZTQGKg04IqSgAQ6E">顶级域名</a>）即可，不需要带 https:&#x2F;&#x2F;（如 baidu.com，而不是 <a href="http://www.baidu.com),github/">http://www.baidu.com），github</a> page 会自动把 www的请求重定向到顶级域名下。</li>
<li>使用 hexo 搭建起来的博客，则是在 source 目录中，来添加 CNAME 文件，然后部署到 github 上面（命令行为 hexo d -g）。</li>
</ul>
</li>
<li><p>域名解析</p>
<ul>
<li>申请好的域名，一般由提供商来进行解析（把域名映射为 IP 地址），我们这里不适用 Godaddy 提供的域名解析（NameServer） 服务，而是使用 NDSPod 作为我们的域名解析商。</li>
<li>申请 NDSPod 账户</li>
<li>在 NDSPod 添加域名、添加 A&#x2F;CNAME 记录<ul>
<li>A 记录</li>
<li>CNAME 记录</li>
</ul>
</li>
<li>在 Godaddy 绑定 DNSPod的域名解析地址</li>
<li>wait a moment</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="HTTPS问题："><a href="#HTTPS问题：" class="headerlink" title="HTTPS问题："></a><strong>HTTPS问题：</strong></h3><ul>
<li>github page 的 ssl证书绑定的是 github.io 的域名。如果在 chrome 中使用 https 访问自定义的域名，会提示<strong>NET::ERR_CERT_COMMON_NAME_INVALID</strong>。</li>
<li>CloudFlare 来做域名解析，开启 ssl 为 Flexble 之后，可以让chrome和 CloudFlare 之间使用 https访问，而CloudFlare 与 github page 中继续使用 http 来访问。</li>
<li>参考文章：<a href="https://blog.chionlab.moe/2016/01/28/github-pages-with-https/">在GitHub Pages上使用CloudFlare https CDN</a></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS ReactNative私有库指南</title>
    <url>/posts/react-native-private-repo/</url>
    <content><![CDATA[<h1 id="创建RN私有库"><a href="#创建RN私有库" class="headerlink" title="创建RN私有库"></a>创建RN私有库</h1><p>为了加速RN的下载和方便集成，我把RN(0.56.0)做成私有pod放到了gitlab的私有源中，参考《<a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/">使用Cocoapods创建私有podspec</a>》、《<a href="https://imfong.com/post/Private-Pods-Add-react-native#yoga">私有Pods集成react-native库</a>》。</p>
<span id="more"></span>

<p>开始之前，需要搞清楚两个概念：</p>
<p>cocoapods 是通过spec repos + pod source code repo 来进行代码版本管理，cocoapods 的<a href="https://github.com/CocoaPods/Specs">master spec repo</a>来管理所有的第三方库 spec，每个 spec 中都包含了对于 pod 的 source code pod。</p>
<p><strong>私有源仓库：</strong>类似于 cocoapods 官方来管理 specs 的仓库，用来管理私有库的 spec，下文中使用<code>YOUR_SPECS_REPO</code>来指代。同时，这个 repo 也有自己的 git 地址，下文使用<code>YOUR_SPECS_GIT</code></p>
<p><strong>私有 pod 代码仓库</strong>：存放私有库 source code 的 repo。</p>
<p>下面是具体的操作步骤：</p>
<h2 id="创建私有ReactNative-repo"><a href="#创建私有ReactNative-repo" class="headerlink" title="创建私有ReactNative repo"></a>创建私有ReactNative repo</h2><ul>
<li>把 github 上的源码 clone 下来，然后 push 到自己的私有库 git 中</li>
<li><strong>仓库代码是github源码</strong></li>
<li>修复0.56.0中WebSocket问题</li>
</ul>
<h2 id="创建-amp-修改-podspec-json"><a href="#创建-amp-修改-podspec-json" class="headerlink" title="创建&amp;修改 podspec.json"></a>创建&amp;修改 podspec.json</h2><ul>
<li><strong>切换到对应的tag commit: 如v0.56.0，下面的yoga和React需要保存version一致。</strong><ul>
<li>然后按照《<a href="https://imfong.com/post/Private-Pods-Add-react-native">私有Pods集成react-native库</a>》中生成和修改了yoga.podspec.json、React.podspec.json，需要修改yoga.podspec.json的source_files和public_header_files</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod ipc spec React.podspec &gt;&gt; React.podspec.json</span><br><span class="line"><span class="built_in">cd</span> ReactCommon/yoga</span><br><span class="line">pod ipc spec yoga.podspec &gt;&gt; yoga.podspec.json</span><br></pre></td></tr></table></figure>

<ul>
<li>修改yoga.podspec.json<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;git&quot;</span>: <span class="string">&quot;YOUR_RN_GIT&quot;</span></span><br><span class="line"><span class="string">&quot;source_files&quot;</span>: <span class="string">&quot;ReactCommon/yoga/**/*.&#123;cpp,h&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;public_header_files&quot;</span>: <span class="string">&quot;ReactCommon/yoga/**/&#123;Yoga,YGEnums,YGMacros&#125;.h&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="lint-amp-push-podspec-json"><a href="#lint-amp-push-podspec-json" class="headerlink" title="lint &amp; push podspec.json"></a>lint &amp; push podspec.json</h2><ul>
<li><p>需要注意的是，修改后的podspec.json文件，需要进行lint校验、上传到私有源，下面是yoga的方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod spec lint yoga.podspec.json --no-clean --verbose --allow-warnings</span><br><span class="line">pod repo push YOUR_SPECS_REPO yoga.podspec.json --allow-warnings</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过上面的方法可以吧RN和yoga添加到私有源中，但是我们pod install的时候，还是会报错</p>
<img src="/posts/react-native-private-repo/Folly-error.png" class="">

<ul>
<li><p>Folly在RN中被CxxBridge、jschelpers等subspecs依赖，Folly.podspec文件本身在RN源码目录third-party-podspecs中，需要把Folly.podspec也上传到私有源中，否则pod install会出现错误</p>
</li>
<li><p>由于Folly在cocoapods公共源中已经没有维护，但是有志愿者维护了一个folly-ios的pod，需要我们添加到私有源中，添加方法和上面类似</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod repo push YOUR_SPECS_REPO Folly.podspec --allow-warnings</span><br></pre></td></tr></table></figure>
<ul>
<li>类似的，我们也需要把React.podspec.json文件提交到私有源中：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod spec lint React.podspec.json --no-clean --fail-fast --verbose --allow-warnings --sources=YOUR_SPECS_GIT,https://github.com/CocoaPods/Specs.git</span><br><span class="line">pod repo push YOUR_SPECS_REPO React.podspec.json --verbose --allow-warnings --sources=YOUR_SPECS_GIT,https://github.com/CocoaPods/Specs.git</span><br></pre></td></tr></table></figure>
最终，我们总共需要添加了三个私有repo：<strong>RN&#x2F;Folly&#x2F;yoga</strong></li>
</ul>
<h2 id="创建离线js-bundle包"><a href="#创建离线js-bundle包" class="headerlink" title="创建离线js bundle包"></a>创建离线js bundle包</h2><p>使用下面命令生成js bundle:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">react-native bundle --dev <span class="literal">true</span> --entry-file index.ios.js --bundle-output ios/main.jsbundle --platform ios</span><br></pre></td></tr></table></figure>

<p>通过–dev参数(true&#x2F;false)控制生成debug&#x2F;release包</p>
<h1 id="如何维护RN版本"><a href="#如何维护RN版本" class="headerlink" title="如何维护RN版本"></a>如何维护RN版本</h1><p>同步Github上的ReactNative源码，在sourceTree中，添加remote:</p>
<img src="/posts/react-native-private-repo/sourcetree.png" class="">

<p>切换到当前的分支(0.57-stable)，可以从github上面拉取最新代码（使用rebase）<br>更新podspec.json</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod ipc spec React.podspec &gt;&gt; React.podspec.json</span><br><span class="line"><span class="built_in">cd</span> ReactCommon/yoga</span><br><span class="line">pod ipc spec yoga.podspec &gt;&gt; yoga.podspec.json</span><br></pre></td></tr></table></figure>

<p><strong>创建RN私有库</strong>的中已经提供了需要修改的地方。</p>
<p><strong>lint &amp; push podspec.json</strong>，或者直接在私有源中进行修改。</p>
<h2 id="RN代码有bug怎么办？"><a href="#RN代码有bug怎么办？" class="headerlink" title="RN代码有bug怎么办？"></a>RN代码有bug怎么办？</h2><p>从RN 0.56.0到RN 0.57.3，都没有解决websocket crash问题。</p>
<p>解决方法：</p>
<ol>
<li><p>查看github issue，寻找问题解决方法。已web socket为例，已经用人<a href="https://github.com/facebook/react-native/pull/19489">提了PR</a></p>
</li>
<li><p>把PR中的源代码下载到本地，然后本地进行验证。验证通过后，则commit &amp;&amp; push到当前tag 所在的分支</p>
</li>
<li><p>由于更新了RN源码，我们需要修改私有库中tag对应的commit：</p>
<ol>
<li>删除之前的tag（0.57.3），在最新的commit中来添加新tag（0.57.3)</li>
<li>在React.podspec.json中，使用branch替代tag</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;source&quot;: &#123;</span><br><span class="line">    &quot;git&quot;: &quot;YOUR_RN_GIT&quot;,</span><br><span class="line">    &quot;branch&quot;: &quot;0.57-stable&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h1 id="专治疑难杂症"><a href="#专治疑难杂症" class="headerlink" title="专治疑难杂症"></a>专治疑难杂症</h1><h2 id="RN-0-56-0-问题："><a href="#RN-0-56-0-问题：" class="headerlink" title="RN 0.56.0 问题："></a><strong>RN 0.56.0 问题：</strong></h2><ul>
<li><p><a href="https://github.com/facebook/react-native/issues/21086"><strong>com.squareup.SocketRocket.NetworkThread(18): EXC_BAD_ACCESS</strong></a></p>
<ul>
<li>解决的PR:<a href="https://github.com/facebook/react-native/pull/19489">https://github.com/facebook/react-native/pull/19489</a></li>
</ul>
</li>
<li><p><a href="https://github.com/facebook/react-native/issues/20567"><strong>WebSocket <code>registerEvents</code> is undefined when running master</strong></a></p>
<ul>
<li>解决方法：<a href="https://stackoverflow.com/a/52486616">https://stackoverflow.com/a/52486616</a></li>
</ul>
</li>
</ul>
<h2 id="RN-0-57-3-问题："><a href="#RN-0-57-3-问题：" class="headerlink" title="RN 0.57.3 问题："></a><strong>RN 0.57.3 问题：</strong></h2><ul>
<li><p><strong>Unable to resolve module <code>schedule/tracking</code></strong></p>
<img src="/posts/react-native-private-repo/schedule-error.png" class=""></li>
</ul>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h1><ul>
<li><p><a href="https://github.com/facebook/react-native/issues/19892">swift cocoapods Could not build Objective-C module ‘React’</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/611b49ccf351">含泪导入React-native 0.54到Swift原生项目</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/57ed76e90605">React Native 0.50.0 集成遇到的问题</a></p>
</li>
<li><p>《<a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/">使用Cocoapods创建私有podspec</a>》</p>
</li>
<li><p>《<a href="https://imfong.com/post/Private-Pods-Add-react-native#yoga">私有Pods集成react-native库</a>》</p>
</li>
<li><p><a href="https://stackoverflow.com/questions/32304421/whats-the-difference-between-pod-spec-lint-and-pod-lib-lint">What’s the difference between ‘pod spec lint’ and ‘pod lib lint’?</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title>关于HTTP/2 的那些事</title>
    <url>/posts/http2-overview/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为客户端研发童鞋，HTTP 协议想必大家都算比较熟悉了，下面几个简单问题应该可以轻松回答：HTTP 的响应码有哪些？HTTP 301&#x2F;302分别是做什么的？Cookie 和 Session 是做什么的？哪些请求是“幂等”？…</p>
<p>但是对于 HTTP&#x2F;2 往往了解比较少，本文主要基于 HTTP&#x2F;2协议来回答几个问题：</p>
<ol>
<li>HTTP&#x2F;1.x有哪些主要问题？</li>
<li>为什么不用 HTTP&#x2F;2.0的命名？</li>
<li>HTTP&#x2F;2是什么？</li>
<li>HTTP&#x2F;2的兼容性怎么样？</li>
<li>HTTP&#x2F;2有哪些关键特性？</li>
<li>HTTP&#x2F;2使用现状如何?</li>
</ol>
<span id="more"></span>

<p>已经清楚答案的童鞋请出门左拐(￣.￣)(￣.￣)</p>
<h2 id="HTTP-x2F-1-x有哪些主要问题？"><a href="#HTTP-x2F-1-x有哪些主要问题？" class="headerlink" title="HTTP&#x2F;1.x有哪些主要问题？"></a>HTTP&#x2F;1.x有哪些主要问题？</h2><ul>
<li><strong>header 冗余</strong></li>
</ul>
<p>HTTP&#x2F;1.x 头字段通常是重复且冗长的，而且每次网络请求都需要带上一些重复的信息（e.g cookie、UserAgent等），导致不必要的网络流量以及导致初始TCP拥塞窗口被快速的填满。当在新的 TCP 连接上发出多个请求时，这可能导致过多的延迟。</p>
<ul>
<li><strong>队头阻塞（head-of-line blocking）</strong></li>
</ul>
<p>HTTP&#x2F;1.0 在给定的 TCP 连接上一次只允许一个请求未完成。HTTP&#x2F;1.1 添加了请求流水线操作(request pipelining)，但这只是部分地解决了请求并发性，并且仍然受到<strong>队首阻塞</strong>的影响。因此，需要发出许多请求的 HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 客户端使用多个连接到服务器以实现并发，从而减少延迟。</p>
<h2 id="为什么不用-HTTP-x2F-2-0的命名？"><a href="#为什么不用-HTTP-x2F-2-0的命名？" class="headerlink" title="为什么不用 HTTP&#x2F;2.0的命名？"></a>为什么不用 HTTP&#x2F;2.0的命名？</h2><p>HTTP&#x2F;2 是由 <a href="http://www.ietf.org/">IETF</a> 的 <a href="https://httpwg.github.io/">HTTP 工作组</a>开发的，该工作组维护 HTTP 协议。它由许多 HTTP 实现、用户、网络运营商和 HTTP 专家组成。</p>
<p>他们认为以前的“1.0”“1.1”造成了很多的混乱和误解，让人在实际的使用中难以区分差异，所以就决定 HTTP 协议不再使用小版本号（minor version），只使用大版本号（major version），从今往后 HTTP 协议不会出现 HTTP&#x2F;2.0、2.1，只会有“HTTP&#x2F;2”“HTTP&#x2F;3”……</p>
<p>这样就可以明确无误地辨别出协议版本的“跃进程度”，让协议在一段较长的时期内保持稳定，每当发布新版本的 HTTP 协议都会有本质的不同，绝不会有“零敲碎打”的小改良。</p>
<h2 id="HTTP-x2F-2是什么？"><a href="#HTTP-x2F-2是什么？" class="headerlink" title="HTTP&#x2F;2是什么？"></a>HTTP&#x2F;2是什么？</h2><p>早年 Google 的童鞋为了优化 HTTP&#x2F;1.1 协议，在实验室捣鼓了 SPDY协议，后面与HTTP 工作组一起合作参与了 HTTP&#x2F;2的协议制定，下面是关于 HTTP&#x2F;2的一些关键时间点：</p>
<ul>
<li><p>2012 年 3 月: 征集 HTTP&#x2F;2 建议</p>
</li>
<li><p>2012 年 11 月: 第一个 HTTP&#x2F;2 草案（基于 SPDY）</p>
</li>
<li><p>2014 年 8 月: HTTP&#x2F;2 草案 17 和 HPACK 草案 12 发布</p>
</li>
<li><p>2014 年 8 月: 工作组最后一次征集 HTTP&#x2F;2 建议</p>
</li>
<li><p>2015 年 2 月: IESG 批准 HTTP&#x2F;2 和 HPACK 草案</p>
</li>
<li><p>2015 年 5 月: RFC 7540 (HTTP&#x2F;2) 和 RFC 7541 (HPACK) 发布</p>
</li>
</ul>
<p>这里主要介绍HTTP&#x2F;2的几个重点内容：scheme&amp; 端口号、建连过程和协议格式。</p>
<ul>
<li>scheme&amp;端口号</li>
</ul>
<p>HTTP&#x2F;2 使用 HTTP&#x2F;1.1 使用的相同 “http” 和 “https” URI scheme，HTTP&#x2F;2 共享相同的默认端口号: “http” URI 为 80，”https” URI 为 443。</p>
<ul>
<li>建连过程</li>
</ul>
<p>HTTP&#x2F;2 的初始请求是通过 HTTP&#x2F;1.1的请求来进行升级的，这样如果服务器不支持 HTTP&#x2F;2就可以继续使用 HTTP&#x2F;1.1来进行通信（这个和 WebSocket 建连过程类似）</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-http"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com</span></span><br><span class="line"><span class="language-http"></span></span><br><span class="line"><span class="language-http"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade, HTTP2-Settings</span></span><br><span class="line"><span class="language-http"></span></span><br><span class="line"><span class="language-http"><span class="attribute">Upgrade</span><span class="punctuation">: </span>h2c</span></span><br><span class="line"><span class="language-http"></span></span><br><span class="line"><span class="language-http"><span class="attribute">HTTP2-Settings</span><span class="punctuation">: </span>&lt;base64url encoding of HTTP/2 SETTINGS payload&gt;</span></span><br></pre></td></tr></table></figure>



<p>如何服务器不支持 HTTP&#x2F;2，则返回 HTTP&#x2F;1.1的响应:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"></span><br><span class="line"><span class="language-arcade">Content-<span class="built_in">Length</span>: <span class="number">243</span></span></span><br><span class="line"><span class="language-arcade"></span></span><br><span class="line"><span class="language-arcade">Content-Type: <span class="built_in">text</span>/html</span></span><br><span class="line"><span class="language-arcade"></span></span><br><span class="line"><span class="language-arcade"></span></span><br><span class="line"><span class="language-arcade"></span></span><br><span class="line"><span class="language-arcade">...</span></span><br></pre></td></tr></table></figure>



<p>如何服务器支持 HTTP&#x2F;2，则通过 101(交换协议)响应接受升级:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"></span><br><span class="line"><span class="language-avrasm"><span class="symbol">Connection:</span> Upgrade</span></span><br><span class="line"><span class="language-avrasm"></span></span><br><span class="line"><span class="language-avrasm"><span class="symbol">Upgrade:</span> h2c</span></span><br><span class="line"><span class="language-avrasm"></span></span><br><span class="line"><span class="language-avrasm"></span></span><br><span class="line"><span class="language-avrasm"></span></span><br><span class="line"><span class="language-avrasm">[ HTTP/<span class="number">2</span> connection ...</span></span><br></pre></td></tr></table></figure>



<ul>
<li>协议格式</li>
</ul>
<p>在 HTTP&#x2F;1.1 中，头信息是文本编码(ASCII编码)，数据包体可以是二进制也可以是文本。</p>
<p>和 HTTP&#x2F;1.x最大的区别：HTTP&#x2F;2 是一个彻彻底底的<strong>二进制协议，头信息和数据包体都是二进制的，统称为“帧”</strong>。使用二进制作为协议实现方式的好处，更加灵活。</p>
<p>在 HTTP&#x2F;1.1 中的一个消息是由 Start Line + header + body 组成的，而 HTTP&#x2F;2 中一个消息是由 <strong>HEADER frame</strong> + 若干个 <strong>DATA frame</strong> 组成的，如下图：</p>
<img src="/posts/http2-overview/HTTP2-overview.png" class="">



<p>关于 HTTP&#x2F;2 不同类型帧（总共 10 种）的内容太多了，这里就不赘述了感兴趣的童鞋可以参见<a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/HTTP%3A2-HTTP-Frames-Definitions.md#http2-%E4%B8%AD%E7%9A%84%E5%B8%A7%E5%AE%9A%E4%B9%89">《HTTP&#x2F;2 中的帧定义》</a></p>
<h2 id="HTTP-x2F-2的兼容性怎么样？"><a href="#HTTP-x2F-2的兼容性怎么样？" class="headerlink" title="HTTP&#x2F;2的兼容性怎么样？"></a>HTTP&#x2F;2的兼容性怎么样？</h2><p>HTTP&#x2F;2 最大限度的兼容 HTTP&#x2F;1.1 原有行为：</p>
<ol>
<li>在应用层上修改，基于并充分挖掘 TCP 协议性能。</li>
<li>客户端向服务端发送 request 请求的模型没有变化。</li>
<li>scheme 没有发生变化，没有 http2:&#x2F;&#x2F;</li>
<li>使用 HTTP&#x2F;1.X 的客户端和服务器可以无缝的通过代理方式转接到 HTTP&#x2F;2 上。</li>
<li>不识别 HTTP&#x2F;2 的代理服务器可以将请求降级到 HTTP&#x2F;1.X。</li>
</ol>
<h2 id="HTTP-x2F-2有哪些关键特性？"><a href="#HTTP-x2F-2有哪些关键特性？" class="headerlink" title="HTTP&#x2F;2有哪些关键特性？"></a>HTTP&#x2F;2有哪些关键特性？</h2><ul>
<li><p>头部压缩信息：一些重复信息（如 Cookie&#x2F;UserAgent&#x2F;Accept&#x2F;Server等 ）在 HTTP&#x2F;1.x中每次都需要传输到服务器。为了减小网络开销、提高传输效率，主要通过2个手段进行优化：</p>
<ul>
<li>头信息专门的“<strong>HPACK</strong>”算法压缩后再发送</li>
</ul>
</li>
<li><p>客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了</p>
</li>
<li><p>基于二进制流的“帧”：在 HTTP&#x2F;2 中定义了 10 种不同类型的帧</p>
<ul>
<li>消息是由 HEADER frame + 若干个 DATA frame 组成</li>
</ul>
</li>
<li><p>多路复用：解决了原来的序列和阻塞机制</p>
<ul>
<li><strong>乱序请求</strong>：HTTP&#x2F;2 把每个 request 和 response 的数据包称为一个数据流(stream)，每个数据流都有自己全局唯一的编号。每个数据包在传输过程中都需要标记它属于哪个数据流 ID，客户端发出的数据流，ID 一律为奇数，服务器发出的，ID 为偶数。</li>
</ul>
</li>
<li><p><strong>优先级排序</strong>：可以对请求进行优先级排序，使更多重要请求更快地完成，从而进一步提高性能。</p>
</li>
<li><p><strong>请求可取消</strong>：数据流在发送中的任意时刻，客户端和服务器都可以发送信号(RST_STREAM 帧)，取消这个数据流。HTTP&#x2F;1.1 中想要取消数据流的唯一方法，就是关闭 TCP 连接。而 HTTP&#x2F;2 可以取消某一次请求，同时保证 TCP 连接还打开着，可以被其他请求使用。</p>
</li>
<li><p><strong>服务端主动推送</strong>：允许服务器推测性地将数据发送到需要这些数据的客户端，通过牺牲一些网络流量来抵消潜在的延迟。服务器通过合成请求来完成此操作，并将其作为 PUSH_PROMISE 帧发送。然后，服务器能够在单独的流上发送对合成请求的响应。</p>
</li>
</ul>
<h2 id="HTTP-x2F-2-使用现状如何"><a href="#HTTP-x2F-2-使用现状如何" class="headerlink" title="HTTP&#x2F;2 使用现状如何?"></a>HTTP&#x2F;2 使用现状如何?</h2><p>在浏览器中，Edge，Safari，Firefox 和 Chrome 的最新版本都支持 HTTP&#x2F;2。其他基于 Blink 的浏览器也将支持 HTTP&#x2F;2（例如 Opera 和 Yandex Browser）。有关更多详细信息，请参见<a href="http://caniuse.com/#feat=http2">这里</a>。</p>
<p>还有几种可用的服务器（包括 <a href="https://http2.akamai.com/">Akamai</a>，<a href="https://google.com/">Google</a> 和 <a href="https://twitter.com/">Twitter</a> 的主要站点提供的 beta 支持），以及许多可以部署和测试的开源实现。</p>
<h2 id="HTTP-x2F-3是什么"><a href="#HTTP-x2F-3是什么" class="headerlink" title="HTTP&#x2F;3是什么?"></a>HTTP&#x2F;3是什么?</h2><p>请听下回分解Y(^o^)Y</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>HTTP 协议作是大家日常开发接触最多的网络协议，其不同版本的改进和背后的设计思路值得仔细品读~~</p>
<h2 id="文档资料："><a href="#文档资料：" class="headerlink" title="文档资料："></a>文档资料：</h2><ul>
<li><a href="https://item.jd.com/25496261693.html">《HTTP&#x2F;2基础教程》中文版</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn">HTTP&#x2F;2 简介</a> - <a href="https://developers.google.com/web/fundamentals?hl=zh-cn">Web Fundamentals</a> </li>
<li><a href="https://blog.poetries.top/http-protocol/notes/advance/26-HTTP2%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88.html">《HTTP 协议》</a> </li>
<li>[<a href="https://juejin.cn/post/6844903774339727374">译] HTTP&#x2F;2 常见问题解答 - 掘金</a></li>
<li><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/HTTP%3A2-HTTP-Frames-Definitions.md#http2-%E4%B8%AD%E7%9A%84%E5%B8%A7%E5%AE%9A%E4%B9%89">《HTTP&#x2F;2 中的帧定义》</a></li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
